@startmindmap
<style>
node {
    Padding 5
    HorizontalAlignment center
    LineColor brown
    LineThickness 1.0
    BackgroundColor white
    RoundCorner 10
    FontSize 10
    MaximumWidth 200

}

rootNode {
    FontSize 25
    FontColor brown
    LineStyle 8.0;3.0
    LineColor brown
    BackgroundColor lightyellow
    LineThickness 2.0
    RoundCorner 2
    Shadowing 0.0
}

leafNode {
    LineColor green
    LineThickness 0.5
    RoundCorner 10
    Padding 2
    BackgroundColor white
    FontSize 8
    MaximumWidth 350
    Margin 3
    HorizontalAlignment left
}

arrow {
    LineStyle 0
    LineThickness 0.5
    LineColor green    
}
</style>

* DDD
** Estratégico / Modelagem estratégica
*** Contextos limitados
**** Container contextual, não somente um modelo, frequentemente é uma aplicação ou um serviço de negócio
**** Domínio
***** Cada tipo de organização tem seu próprio domínio de know-how e maneira de fazer as coisas. Esse reino de compreensão e seus métodos para realizar suas operações é seu Domínio
***** Domínio pricipal
****** Onde reside a funcionalidade principal do domínio
***** Subdomínios
****** Os demais domínios que suportam o princial
****** Subdomínios de suporte
****** Subdomínios genéricos
*** Linguagem ubíqua
**** Linguagem do negócio usada por todos num contexto limitado
*** Mapas de contextos
**** Mapa da situação atual de todos os contextos limitados e seus relacionamentos
**** Relacionamentos
***** Parceria
***** Kernel compartilhado
***** Desenvolvimento cliente-servidor
***** Comformista
***** Camada anti-corrupção ACL
***** Serviço de host aberto OHS
***** Linguagem publicada PL
***** Caminhos separados
***** Grande bola de lama


** Tático / Design tático, Conjunto de técnicas usados para construção do Modelo de Domínio
*** Entidades
**** Identidade
***** Criação
****** Pelo usuário
****** Pela aplicação
****** Pelo mecanismo de persistência
******* Identidade substituta
****** Por outro contexto limitado
***** Layer Supertype
***** Imutável / Mantê-la estável
***** Quais as razões para mudar?
**** Primeiro queremos nos concentrar apenas em atributos/propriedades que fornecem identidade e permitem a correspondência em consultas
**** Interface de Revelação de Intenção
**** Regras e Responsabilidades
**** Construção
***** Factory
**** Validação*
***** Atributos / Propriedades
****** Auto-encapsulamento
****** Verificação da sanidade
***** Objetos inteiros
****** Specification
****** Strategy
****** Verificação de atividades mais simples
****** Separar em objetos de validação*
***** Composição de objetos
****** Validações adiadas
****** Em serviços de domínio
***** Rastreamento de mudanças*
****** Event Sourcing
*** Objetos de valor
**** Mede, quantifica ou descreve algo no domínio.
**** Pode ser mantido como imutável.
**** Modela um todo conceitual, compondo atributos relacionados como uma unidade integral.
***** Factory
***** Builder
**** É completamente substituível quando a medição ou descrição muda.
**** Pode ser comparado com outros usando a igualdade de valor.
**** Fornece a seus colaboradores o comportamento Side-Effect-Free.
***** CQS
***** CQRS
***** Substituição em vez de mutação
***** Quando puder, escolha Objetos de valor para modelar integrações. 
**** Tipos padrão
***** enum*
***** State
***** Como agregado
****** Service
****** Factory
**** Testes
***** Demonstrar como os vários objetos no modelo de domínio serão usados pelos clientes e o que esses clientes podem esperar ao usá-los.
**** Implementação
***** Strategy* (Policy) (sem/com) Separated Interface
**** Persistência
***** Repositories
****** ORM e objetos de valor único.
****** ORM e muitos valores serializados em uma única coluna.
****** ORM e muitos valores apoiados por uma entidade de banco de dados.
****** ORM e muitos valores apoiados por uma tabela de junção.
****** Objetos ORM e Enum-as-State.
***** Recuperado junto aos seu agregados e entidades
***** O modelo de dados deve ser subordinado 
*** Serviços
**** Como regra geral, devemos tentar evitar o uso de Repositórios de dentro de Agregados, se possível.
**** de Domínio
***** Sem estado
***** exemplos: \n • Executar um processo de negócios significativo; \n • Transformar um objeto de domínio de uma composição para outra; \n • Calcular um valor que requer entrada de mais de um objeto de domínio.
***** Implementação
****** Interfaces separadas no mesmo Módulo
******* DIP
******* Hexagonal
****** Classes concretas especializadas
**** de Aplicação
**** de transformação
**** de Testes
*** Eventos
**** de Domínio
***** Publish-Subscribe/Observer
****** Não usar a notificação de evento para modificar uma segunda instância do Agregado.
***** Event Store
***** Event Sourcing
****** Enriquecimento de eventos*
***** Consistência eventual
***** Com características de agregado
****** Persistente
****** Imutável ou Id exclusivo
****** Confirmação de duas fases
***** Event Store
****** Estilos arquiteturais
******* RESTfull
******* Messaging Middleware
**** da Aplicação
*** Módulos
**** • Porjetar para se adequar aos conceitos de modelagem.\n• Nomear com a Linguagem ubíqua.\n• Não criar módulos mecanicamente de acordo com com componentes de tipo genérico ou padrões usados na modelagem.\n • Projetar módulos com acoplamento fraco.\n • Se esforçar para ter dependências acíclicas em seus pares onde o acoplamento é necessário.\n• Relaxe um pouco para as regras entre os módulos filho e pai.\n• Não tornar os módulos estáticos, permita-os serem modelados juntos com os objetos que eles organizam.
**** Nomeação
***** • organização.contextolimitado.domínio.modelo.\n• organização.contextolimitado.domínio.serviços...
***** ou modelos e serviços num mesmo Módulo
***** Levar em consideração que os contextos limitados não devem ser usados como um substituto para os módulos. Usar Módulos para modularizar objetos de domínio coesos e para separar aqueles que não são coesos ou menos coesos.
*** Agregados
**** De quem é o trabalho?
**** Mantê-los pequenos
**** Referenciados pelo id fora do seu limite.
**** Simultaneidade
***** Otimista - Versionamento das Entidades
**** Consistência
***** Transacional - Imediata e atômica - dentro dos limites
****** Unit of Work
***** Eventual - fora dos limites
****** Usar como regra
**** Tentar manter várias instâncias de Aggregate consistentes pode estar dizendo a você que sua equipe perdeu uma invariante.
**** Disconnected Domain Model (menos favorável)
***** Quando, opcionalmente, um agregado acessa um outro dentro de sua fronteira usando um repositório (uma forma de carregamento lento).
**** Usar Repository ou Domain Service para pesquisar objetos dependentes antes de invocar o comportamento Agregado.
**** motivos para quebra das regras:
***** CQRS
***** Por conveniência da interface do usuário
***** Falta de mecanismos técnicos
***** Transações globais
***** Desempenho de consulta
**** Estimativa de custos
***** BOTE*
**** Lei de Demeter; Fale, não pergunte.
**** Evitar injeção de Repositórios e Serviços de Domínio em instâncias do Aggregate. 
*** Fábricas
**** Serviços funcionam como Fábricas que produzem Agregados ou Objetos de Valor de vários tipos.
**** Factory Method
**** Abstract Method
***** hierarquia de objetos = dor
*** Reposiórios
**** Fornecer repositórios somente para Agregados (na teoria)
**** Um por repositório
**** DesignedDomainStereotypeFontColor
***** Orientado a coleção
****** Deve imitar uma coleção Set
***** Orientado a persistência
****** Data Fabric
****** NoSQL
****** Colocar explicitamente () objetos novos e alterados no armazenamento, substituindo efetivamente qualquer valor previamente associado à chave fornecida. Usar esses tipos de armazenamento de dados simplifica muito as gravações e leituras básicas de agregados. Por esse motivo, às vezes são chamados de Aggregate Stores ou Aggregate-Oriented Databases.
***** É uma proposta potencialmente cara instanciar um Repositório para cada transação.


left
** Arquitetura
*** Camadas
**** Interface
***** Modelo de apresentação
***** Serviço de host aberto
**** Aplicação
***** Serviços de aplicação
****** Factory
****** Publicador de eventos de domínio
***** Serviços de domínio - ênfase na estratégia do negócio
****** Eventos de domínio
**** Infraestrutura
***** Repositórios
***** Módulos
****** DIP
**** Relacionamentos
***** Estrito - Acoplamento somente às camadas abaixo
***** Relaxado - Camada de nível alto acessa qualquer abaixo
***** Camadas inferiores podem se acoplar livremente às camadas superiores
****** Observer
****** Mediator
*** Hexagonal ou Porta e adaptadores
**** Portas - Canais com o mundo externo
**** Adaptadores - Adapta os dados que trafega pelas porta
*** SOA
**** Pincípios
***** Contrato
***** Acoplamento solto
***** Abstração
***** Autonomia
***** Statelessness
***** Apto a ser descoberto
***** Apto a composição
**** REST / RESTful / SOAP / Mensageria
*** CQRS
**** Separação dos modelos de comandos dos de leitura
**** Comandos
***** Categorizados
****** Cada serviço de aplicativo pode ter vários métodos. A principal vantagem aqui é a simplicidade. Esse tipo de manipulador é bem conhecido, fácil de criar e manter. 
***** Dedicados
****** Cada um seria uma única classe com um método. Isso tem vantagens claras: há uma única responsabilidade por manipulador / processador; cada manipulador pode ser reimplantado independentemente ; os tipos de manipulador podem ser dimensionados para gerenciar grandes volumes de certos tipos de comandos.
****** Permite Assincronia
****** Consistência eventual
**** Leituras
***** Eventos
***** Modelos de dados desnornalizado
**** Pub/Sub
***** Observer
*** Orientada a Eventos EDA
**** Promove a produção, detecção, consumo e reação a eventos
**** Pipe and Filters
***** Pipes são canais de mensagem
***** Portas conecta Filter aos Pipes
***** Filters são processadores
***** Pocessadores separados
***** Acoplamento fraco
***** Intercâmbialidade
***** Filters podese ser multi Pipe
***** Use o mesmo tipo de Filter em paralelo
**** Processo de longa duração / Sagas
***** Tarefa composta
***** Conjunto de atividades num conjunto de agragados
***** Processo sem estado, sendo enriquecido a cada eventos
**** Event-Sourcing
***** Persistência de dos eventos com carimbo de data, sendo possível recriar o agregado em determinado momento do passado
**** Data Fabric e grid-based distributed computing
***** Replicação de dados / cache
***** Suporta o estilo Event-Driven
***** Queries contínuas
***** Processamento distribuído

** Integração de contextos limitados
*** Meios
**** RESTfull
***** Não permite que os clientes sejam completamente autonomos.
**** Mensageria
***** Eventos de domínio
**** RPC
***** Menos resiliência nos tratamentos de erros.
**** outros
*** Princípios da computação distribuída
**** • A rede não é confiável.\n• Sempre há alguma latência, e talvez muita.\n• A largura de banda não é infinita.\n• Não presuma que a rede é segura.\n• Topologias da rede mudam.\n• Conhecimento e políticas são espalhados por vários administradores.\n• O transporte em rede tem custo.\n• A rede é heterogênea.
*** Notificação e Eventos
**** Linguagem publicada
**** Adaptadores
**** • Type: Notification format: JSON\n• notificationId: long integer unique identity\n• typeName: text String type of notification, an example type name being com.saasovation.agilepm.domain.model.product.↵backlogItem.BacklogItemCommitted\n• version: integer version of the notification\n• occurredOn: date/time when the notification’s contained Event happened\n• event: JSON payload details; see specific Event types
**** Os eventos também podem conter com segurança instâncias de Objetos de Valor mais sofisticados (6), o que é especialmente eficaz quando seus tipos de Valor tendem a ser estáveis.
*** Anticorruption Layer
**** • Serviço da aplicação cliente\n• Adaptador\n• Tradutor

@endmindmap